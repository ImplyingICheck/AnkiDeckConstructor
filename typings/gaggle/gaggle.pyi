"""
This type stub file was generated by pyright.
"""

import enum
from _csv import Dialect
from typing import Any, ParamSpec, Protocol, Self, SupportsIndex, SupportsInt, TYPE_CHECKING, TypeVar
from collections.abc import Callable, Iterable, Iterator, MutableMapping, Sized
from _typeshed import ReadableBuffer, StrOrBytesPath, SupportsRead, SupportsReadline, SupportsTrunc, SupportsWrite

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
  _T = TypeVar('_T')
  _T_co = TypeVar('_T_co', covariant=True)
  _T_contra = TypeVar('_T_contra', contravariant=True)
  _S = TypeVar('_S')
  _P = ParamSpec('_P')
  _P_helper = ParamSpec('_P_helper')
  _R = TypeVar('_R')
  class Falsy(Protocol):
    def __bool__(self) -> bool:
      ...
    
  
  
  class SupportsAppend(Protocol[_T_contra]):
    def append(self, obj: _T_contra) -> Any:
      ...
    
  
  
  class Seekable(Protocol):
    def tell(self) -> int:
      ...
    
    def seek(self, __cookie: int, __whence: int = ...) -> int:
      ...
    
  
  
  class SupportsWriteRow(Protocol):
    @property
    def dialect(self) -> Dialect:
      ...
    
    def writerow(self, row: Iterable[str]) -> Any:
      ...
    
  
  
  class SizedAppendable(Sized, SupportsAppend[_T_contra], Protocol[_T_contra]):
    ...
  
  
  class SizedAppendableIterable(SizedAppendable[_T], Iterable[_T], Protocol[_T]):
    ...
  
  
  class ReadableAndSeekable(SupportsRead[_T_co], SupportsReadline[_T_co], Seekable, Protocol[_T_co]):
    ...
  
  
  CastableToInt = (str | ReadableBuffer | SupportsInt | SupportsIndex | SupportsTrunc)
  AnkiHeader = dict[str, str | int] | dict[str, str]
_ANKI_EXPORT_HEADER_LINE_SYMBOL = ...
_ANKI_EXPORT_HEADER_DELIMITER_SYMBOL = ...
_ANKI_EXPORT_ENCODING = ...
_ANKI_EXPORT_HEADER_SETTING_SEPARATOR_NAME = ...
_ANKI_EXPORT_HEADER_SETTING_SEPARATOR_TSV_STRING = ...
class HeaderBoolean(enum.StrEnum):
  FALSE_ = ...
  TRUE_ = ...


_ANKI_EXPORT_HEADER_TRUE = ...
_ANKI_EXPORT_HEADER_FALSE = ...
_ANKI_EXPORT_HEADER_MAPPING = ...
_ANKI_EXPORT_HEADER_MAPPING_REVERSE = ...
_ANKI_ORDERED_HEADER = ...
_ANKI_NOTESINPLAINTEXT_EXT = ...
_ANKI_CARDSINPLAINTEXT_EXT = ...
_ANKI_EXPORT_CONTENT_DIALECT = ...
GENERIC_EXPORT_FILE_NAME = ...
class ReformatDirection(enum.StrEnum):
  ANKI_TO_GAGGLE = ...
  GAGGLE_TO_ANKI = ...


_DIRECTION_TRANSLATION_VALUE = ...
_DIRECTION_MAPPING = ...
def propagate_warnings(stack_level: int) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]:
  """Captures output warnings and adjusts the context line of the warning to
  reflect the frame specified by stack_level."""
  ...

def propagate_warnings_from_generator(stack_level: int) -> Callable[[Callable[_P, Iterator[_R]]], Callable[_P, Iterator[_R]]]:
  ...

def generate_flattened_kwargs_fill_missing(fillvalue: _S = ..., **kwargs: Iterable[_T] | Iterator[_T]) -> Iterator[dict[str, _T | _S]]:
  """Generator which yields a dictionary of keywords to arguments. The values
  have lazy evaluation and missing arguments are filled with fillvalue.

  For usage with arguments which evaluate to False, see documentation for
  generate_flattened_kwargs_remove_sentinel(). To remove all falsy arguments,
  see documentation for generate_flattened_kwargs_remove_falsy().

  Args:
    fillvalue: Any value with which missing arguments are filled
    **kwargs: An iterable containing arguments

  Yields:
    Dictionary mapping keyword to arguments. Each dictionary contains the
    arguments that would be found at the same "index" i as if **kwargs
    contained lists. For example, having i as 5:

    {'param_x_keyword': argument_x5,
     'param_y_keyword': argument_y5,
     'param_z_keyword': argument_z5}

    Returned keys always strings. This function will fill missing arguments
    with the specified fillvalue. Taking our previous example, let us say
    "argument_y5" was not passed in but "param_y_keyword" is a key in the
    **kwargs passed in. We have the "fillvalue" object(). For example:

    {'param_x_keyword': argument_x5,
     'param_y_keyword': object(),
     'param_z_keyword': argument_z5}
    """
  ...

def generate_flattened_kwargs_remove_falsy(**kwargs: Iterable[_T]) -> Iterator[dict[str, _T]]:
  """Generator which yields a dictionary of keywords to arguments. The values
  have lazy evaluation and falsy values are not returned.

  To remove all falsy arguments, see documentation for
  generate_flattened_kwargs_remove_falsy(). To fill missing arguments, see
  documentation for generate_flattened_kwargs_fill_missing().

  Args:
    **kwargs: An iterable containing arguments

  Yields:
    Dictionary mapping keyword to arguments. Each dictionary contains the
    arguments that would be found at the same "index" i as if **kwargs contained
    lists. For example, having i as 5:

    {'param_x_keyword': argument_x5,
     'param_y_keyword': argument_y5,
     'param_z_keyword': argument_z5}

    Returned keys always strings. This function will remove any argument which
    evaluates to False. Taking our previous example, let us say
    argument_y5 == None and argument_x5 == ''. For example:

    {'param_z_keyword': argument_z5}
  """
  ...

def generate_flattened_kwargs_remove_sentinel(sentinel: Any = ..., fillvalue: _S = ..., **kwargs: Iterable[_T]) -> Iterator[dict[str, _T | _S]]:
  """Generator which yields a dictionary of keywords to arguments. The values
  have lazy evaluation and only arguments which match sentinel are removed.
  Missing arguments are filled with fillvalue.

  To remove missing arguments for which the parameter has been specified,
  ensure sentinel and fillvalue are equal.

  To remove all falsy arguments, see documentation for
  generate_flattened_kwargs_remove_falsy(). To only fill missing arguments, see
  documentation for generate_flattened_kwargs_fill_missing().

  Args:
    sentinel: Any value for which matching arguments should be removed
    fillvalue: Any value with which missing arguments are filled
    **kwargs: An iterable containing arguments

  Yields:
    Dictionary mapping keyword to arguments. Each dictionary contains the
    arguments that would be found at the same "index" i as if **kwargs
    contained lists. For example, having i as 5:

    {'param_x_keyword': argument_x5,
     'param_y_keyword': argument_y5,
     'param_z_keyword': argument_z5}

    Returned keys always strings. Unlike the generate_flattened_kwargs()
    function, this function will remove any argument which matches sentinel.
    Taking our previous example, let us say argument_x5 == None and
    "argument_y5" was not passed in but 'param_y_keyword' is a key in the
    **kwargs passed in. Let sentinel == None and fillvalue == ''. For example,

    {'param_y_keyword': '',
     'param_z_keyword': argument_z5}
      """
  ...

class Gaggle:
  """
  Parser class for Anki exported files.
  Handles deck construction and organisation.
  """
  def __init__(self, exported_file: StrOrBytesPath | None = ..., field_names: Iterable[str] | None = ...) -> None:
    """

    Args:
      exported_file:
      field_names:

    Raises:
      FileNotFoundError: If file specified by exported_file does not exist
    """
    ...
  
  def __iter__(self):
    ...
  
  def add_deck(self, deck: AnkiDeck) -> None:
    ...
  
  def add_deck_from_file(self, file: str) -> None:
    """

    Args:
      file:

    Returns:

    """
    ...
  
  def write_deck_to_file(self, deck: AnkiDeck | int, filename: str | None = ..., file_type: str = ..., destination: str = ..., extension: str = ...) -> None:
    """Writes a deck to a location in file storage. Supports various file naming
    features. See documentation for _generate_unique_file_path() for details on
    how the path is calculated. Will generate a unique filename if one is not
    given.

    Args:
      deck: A Deck object or an index indicating which deck to write.
      filename: The name to give to the newly created file. If none or if not
      unique, filename is generated by _generate_unique_file_path().
      file_type: The file type as designated by Anki. See
      (https://docs.ankiweb.net/exporting.html) for more information.
      destination: The directory to which the file will be written to.
      extension: The file extension, written after filename. Does not change
      functionality of written file and is purely for naming.

    Raises:
      OSError: Uses builtin open(). See open() Python documentation for more
      details (https://docs.python.org/3/library/functions.html#open)
      FileExistsError: _generate_unique_file_path() will generate unique
      filenames if a file already exists in a given path. Will not raise.
      ValueError: If argument passed for file_type is not a supported file type
    """
    ...
  
  def write_all_decks_to_file(self, **kwargs: Iterable[str | None]) -> None:
    """Writes all Decks stored in Gaggle to file. **kwargs is flattened and
    write_deck_to_file is called with each group of arguments. If there are more
    Decks than argument groups, prints the remaining decks using default values.
    **kwargs names and default values can be found in documentation for
    write_deck_to_file().

    Args:
      **kwargs: Dictionary of keyword to iterable of arguments. For more
      information, see documentation for write_deck_to_file()

    Raises:
      DecksNotWrittenException: If method fails to write all Decks to file.
      ValueError: See documentation for write_deck_to_file() for details
    """
    ...
  
  def get_deck(self, idx: int) -> AnkiDeck:
    ...
  
  def print_decks(self) -> None:
    """Outputs each AnkiCard contained in each Deck within the Gaggle to
    standard output using print() Python builtin.
    """
    ...
  


def transform_integer_value(value: CastableToInt, translation: int = ..., scale: int = ...) -> CastableToInt | int:
  """Attempt to convert value into an int(). If successful, translate the
  resulting int and then scale it. If value cannot be converted, it is returned
  as is.

  For specifics on which values can be converted, see Python documentation for
  int().

  Args:
    value: The item to be cast into int
    translation: A mathematical translation, added to value
    scale: A mathematical scaling, multiplied with value

  Returns:
    The value unchanged if it cannot be converted. Otherwise, a translated then
    scaled int.
  """
  ...

def reformat_header_settings(header: MutableMapping[str, Any], direction: ReformatDirection) -> None:
  """Convert between Anki header naming style and Gaggle header naming style.
  For more information on Anki header style, see documentation for
  gaggle.AnkiCard for a link to official Anki documentation. The Gaggle header
  naming style is snake case and uses 0-indexing.

  Transforms header in place.

  Args:
    header: A header read from an Anki file. Original entries are deleted and
    replaced by reformatted entries.
    direction: Denotes which style format the header should be converted to.
    Specified by gaggle.ReformatDirection enum.

  Returns:
    None; transforms header in place.

  Raises:
    KeyError: If argument passed for direction is not a supported conversion
  """
  ...

def read_header_settings(f: ReadableAndSeekable[str]) -> AnkiHeader:
  """Reads in Anki Header from a stream and stores it into a dictionary. Strips
  all trailing whitespace characters from header value.

  Assumes input of a specific format, see documentation for parameter f.

  Args:
    f: A stream containing Anki Header information. Assumes input of format
    <header symbol><header setting name><header delimiter><header setting value>
    where header symbol is the denotation that the line is a part of the file
    header. The stream is left at the first line which does not contain
    <header symbol> as its first component. <header symbol> and
    <header delimiter> are specified by gaggle module constants.

  Returns:
    A mapping of settings specified by the Anki file header.
  """
  ...

def parse_header_settings(f: ReadableAndSeekable[str]) -> AnkiHeader:
  """Reads in all Anki file header settings, producing a mapping of setting
  name to setting value. Then reformats this mapping and returns it.

  Args:
    f: A stream from which lines are read. Read until no longer contains header
    information; stream left at first line with no header information, may be
    depleted. See read_header_settings() for more information.

  Returns:
    A mapping of setting name to setting value. The settings are formatted to
    ensure internal consistency with AnkiCard and AnkiDeck. See
    reformat_header_settings() documentation for more information.
  """
  ...

class AnkiDeck:
  """Represents a collection of Notes and Cards exported from Anki
  (i.e. gaggle.AnkiCards).

  Attributes:
    header: A dictionary mapping setting names to the setting value. The setting
    value is an int if it references a column of parsed data.
    cards: An iterable of gaggle.AnkiCards
  """
  def __init__(self, header: AnkiHeader, cards: Iterable[AnkiCard]) -> None:
    ...
  
  @classmethod
  def from_file(cls, file: StrOrBytesPath, field_names: Iterable[str] | None = ...) -> Self:
    """Factory method to create an AnkiDeck directly from a file.

    Args:
      file: A string representing the file path of the information used to
      construct the deck.
      field_names: Strings representing the name of each field in each card. See
      documentation for _generate_unique_field_names() for details on usage and
      structure.

    Returns:
      A gaggle.AnkiDeck object. See AnkiDeck documentation for more information.

    Raises:
      FileNotFoundError: If file specified by file does not exist
    """
    ...
  
  def __iter__(self):
    ...
  
  def get_header_setting(self, setting_name: str, default: Any = ...) -> str | int:
    """Return the value of a header setting, referenced by name

    Args:
      setting_name: String representing the name of the setting, as named in
      Gaggle representation. A conversion from Anki naming to Gaggle naming can
      be referenced in _ANKI_EXPORT_HEADER_MAPPING.
      default: The value to return if no header setting with the given name is
      found.

    Returns:
      The found setting as stored. Else, default if a setting by name
      setting_name is not found.
    """
    ...
  
  def write_header(self, f: SupportsWrite[str]) -> None:
    """Outputs header settings stored in self.header.

    Setting a header value to None will prevent it from being output.

    Args:
      f: A stream implementing write(). See Gaggle.write_deck_to_file() for an
      example using open().

    Raises:
      KeyError: If AnkiDeck.header contains a header name not supported by
      reformat_header_settings()
    """
    ...
  
  def write_as_tsv(self, f: SupportsWrite[str]) -> None:
    """Outputs header settings associated with deck. Then outputs the data
    fields of each AnkiCard stored in self.cards. One card per row.

    Requires only a stream to improve reusability as a public API. See
    Gaggle.write_deck_to_file() for a simpler setup.

    Args:
      f: A stream implementing write(). See Gaggle.write_deck_to_file() for an
      example using open().
    """
    ...
  


def create_cards_from_tsv(f: Iterable[str], field_names: Iterable[str] | None = ..., header: AnkiHeader | None = ...) -> list[AnkiCard]:
  """Breaks each entry of f using Excel TSV style rules. Then constructs an
  AnkiCard from the delimited strings.

  Args:
    f: Typically a stream from builtin open()
    field_names: The names to be used for each field per entry in f. Used for
    reference only. See documentation for _generate_unique_field_names() for
    more information.
    header: The settings with which to initialise each AnkiCard.

  Returns:
    A list of AnkiCards. Useful for constructing an AnkiDeck.
  """
  ...

_stack_levels_to_anki_card_init_call = ...
class AnkiCard:
  """
  Anki Card fields as denoted by Anki documentation
  Up to date reference:
  https://docs.ankiweb.net/importing.html#file-headers
  Permanent Reference [09 May 2023]:
  https://github.com/ankitects/anki-manual/blob/0aa372146d10e299631e361769f41533a6d4a417/src/importing.md?plain=1#L196-L220
  """
  _reserved_names = ...
  def __init__(self, fields: Iterable[str], field_names: Iterable[str] | None = ..., has_html: str = ..., tags_idx: int | None = ..., note_type_idx: int | None = ..., deck_idx: int | None = ..., guid_idx: int | None = ...) -> None:
    ...
  
  @property
  def tags(self) -> str:
    """This property is a reserved name, a field cannot be manually named
    Note Type. It must be set using the tags_idx parameter of AnkiCard.

    Returns:
      Anki program tags, delimited with '::' when generated by Anki

    Raises:
      KeyError: If no field with the name 'Tags' exists
    """
    ...
  
  @property
  def note_type(self) -> str:
    """This property is a reserved name, a field cannot be manually named
    Note Type. It must be set using the note_type_idx parameter of AnkiCard.

    Returns:
      Anki program note type. This name reflects the expected fields and
      css/html within the Anki program.

    Raises:
      KeyError: If no field with the name 'Note Type' exists
    """
    ...
  
  @property
  def deck_name(self) -> str:
    """This property is a reserved name, a field cannot be manually named
    Deck. It must be set using the deck_idx parameter of AnkiCard.

    Returns:
      Anki program deck name, delimited with '::' when generated by Anki.
      This reflects the nested structure of decks saved within the Anki program,
      where the outer layer is ordered first. For example:

      'First Grouping::First Subgroup::Deck 3'

    Raises:
      KeyError: If no field with the name 'Deck' exists
    """
    ...
  
  @property
  def guid(self) -> str:
    """This property is a reserved name, a field cannot be manually named
    GUID. It must be set using the guid_idx parameter of AnkiCard.

    Returns:
      A GUID used internally by the Anki program. It is used to update existing
      cards should a card with a matching GUID be imported. Per Anki
      documentation, it is not recommended to manually set this value yourself.

    Raises:
      KeyError: If no field with the name 'GUID' exists
    """
    ...
  
  def __repr__(self):
    ...
  
  def get_field(self, field_name: str) -> str:
    ...
  
  def as_str_list(self) -> list[str]:
    """Return data fields of AnkiCard. Preserves read-in order.

    Returns:
      List of strings. Each string is an individual data value stored in
      AnkiCard. The order of the strings is the same order as the AnkiCard was
      read from file.

      Assume a file with three values was read. For example:

      [column0, column1, column2]

    """
    ...
  
  def write_as_tsv(self, w: SupportsWriteRow) -> None:
    """Output data fields of AnkiCard in TSV format.

    Requires only a stream to improve reusability as a public API. See
    AnkiDeck.write_as_tsv() for a simpler setup.

    Args:
      w: The stream to write to. Must have internal formatting data.
        See AnkiDeck.write_as_tsv() for an example using csv.writer.
    """
    ...
  


